const _VERSION="2.00",_VISIT_ST=Object.freeze({UNVISITED:0,VISITED:1,FULLY_VISITED:2});class MeshesFinder{constructor(){this.adjacencyList={}}addVertex(e){this.adjacencyList[e]||(this.adjacencyList[e]=[])}addEdge(e,t){this.adjacencyList[e]||this.addVertex(e),this.adjacencyList[t]||this.addVertex(t),-1===this.adjacencyList[e].indexOf(t)&&this.adjacencyList[e].push(t),-1===this.adjacencyList[t].indexOf(e)&&this.adjacencyList[t].push(e)}removeEdge(e,t){this.adjacencyList[e]=this.adjacencyList[e].filter(e=>e!==t),this.adjacencyList[t]=this.adjacencyList[t].filter(t=>t!==e)}removeVertex(e){for(;this.adjacencyList[e];){const t=this.adjacencyList[e].pop();this.removeEdge(e,t)}delete this.adjacencyList[e]}buildEdges(){for(let e=0;e<this.incMatrix.length-1;e++){const t=e;for(let s=e+1;s<this.incMatrix.length;s++){const e=s,r=this.incMatrix[t],n=this.incMatrix[e];for(let s=0;s<r.length;s++){r[s]&n[s]&&this.addEdge(t,e)}}}return{error:{state:!1,reason:"OK"},data:{}}}initGraph(e,t,s,r,n=!1){this.adjMatrix=e,this.incMatrix=t,this.vertices=s,this.edges=r,this.incMatrix.length&&this.buildEdges(),n&&(console.table(this.vertices),console.table(this.edges),console.table(this.adjMatrix),console.table(this.incMatrix))}dfsRecursive(e){let t={errorCode:0,data:[]},s=this.adjacencyList,r=[{vertex:e,skip:[]}],n={},i=[],a=!1;do{let t=r[r.length-1].vertex;if(n[t]==_VISIT_ST.FULLY_VISITED)n[t]=_VISIT_ST.UNVISITED,0==n[e]?a=!0:r[r.length-2].skip.push(r.pop().vertex);else{n[t]=_VISIT_ST.VISITED;for(let a=0;a<s[t].length;a++){const h=s[t][a];if(!r[r.length-1].skip.includes(h)){if(a==s[t].length-1&&(n[t]=_VISIT_ST.FULLY_VISITED),!n[h]){r.push({vertex:h,skip:[]});break}h==e&&i.push(JSON.parse(JSON.stringify(r)))}}}}while(!a);for(let e=0;e<i.length;e++){const s=i[e];let r=[];for(let e=0;e<s.length;e++){const t=s[e];r.push(t.vertex)}t.data.push(r)}return t}getMeshes(e=1){let t={error:{state:!1,reason:"OK"},data:{}};function s(e,t){const s=JSON.parse(JSON.stringify(e)),r=JSON.parse(JSON.stringify(t));return JSON.stringify(s.sort())==JSON.stringify(r.sort())}function r(e,t){let s=JSON.parse(JSON.stringify(e));for(let e=0;e<s.length;e++)for(let r=0;r<s[e].length;r++)s[e][r]=t[s[e][r]];return{errorCode:0,data:s}}function n(e){let t=[],s=1,r=e.length;if(2==r)s=.5*(e[0].branches.length*e[0].branches.length-e[0].branches.length);else for(let t=0;t<r;t++){s*=e[t].branches.length}for(let s=0;s<e.length;s++){const n=e[s];if(2==r){let e=[];for(let t=0;t<n.branches.length;t++){const s=n.branches[t];for(let r=t+1;r<n.branches.length;r++){const t=n.branches[r];e.push([[s],[t]])}}t=JSON.parse(JSON.stringify(e))}else if(0==t.length)for(let e=0;e<n.branches.length;e++)t.push([n.branches[e]]);else{let e=[];for(let s=0;s<t.length;s++){const r=t[s];for(let t=0;t<n.branches.length;t++)e.push(JSON.parse(JSON.stringify(r))),e[e.length-1].push(n.branches[t])}t=JSON.parse(JSON.stringify(e))}}return{errorCode:0,data:t}}console.log("Meshes-finder v"+_VERSION+" started the job..."),console.time("meshes-finder-duration");let i=[];for(let e=0;e<this.vertices.length;e++){let t=this.dfsRecursive(e).data;for(let e=0;e<t.length;e++){const s=t[e];let r=!1;for(let e=0;e<i.length;e++){const t=i[e];if(a=s,h=t,JSON.stringify(a)==JSON.stringify(h)){r=!0;break}}r||i.push(s)}}var a,h;for(let e=0;e<i.length;e++){const t=i[e];if(2==t.length){const s=this.incMatrix[t[0]],r=this.incMatrix[t[1]];let n=0;for(let e=0;e<s.length;e++){s[e]&r[e]&&n++}if(n<2)i.splice(e,1),e--;else if(n>2)for(let s=0;s<n-1;s++)i.unshift([t[0],t[1]]),e++}}let l=[];for(let e=0;e<i.length;e++){const t=i[e];let s={fullpath:t,hops:[]},r=0,n=0;for(let e=0;e<t.length;e++){n=(r=e)<t.length-1?e+1:0;const i=t[r],a=t[n];let h={source:i,destination:a,branches:[]};const l=this.incMatrix[i],o=this.incMatrix[a];for(let e=0;e<l.length;e++){l[e]&o[e]&&h.branches.push(e)}s.hops.push(JSON.parse(JSON.stringify(h)))}l.push(JSON.parse(JSON.stringify(s)))}let o=[];for(let e=0;e<l.length;e++){let t=r(n(l[e].hops).data,this.edges).data;for(let e=0;e<t.length;e++)o.push(t[e])}let c=[];for(let e=0;e<o.length;e++){const t=o[e];let r=!1;for(let e=0;e<c.length;e++){if(s(t,c[e])){r=!0;break}}r||c.push(t)}let d=function(e){let t=JSON.parse(JSON.stringify(e)),s=0,r=0;for(let e=0;e<t.length;e++){let n=t[e].length;n>r&&(r=n),s++}let n={order:new Array(r+1),info:{count:new Array(r+1),total:s,ordermax:r}};for(let e=0;e<n.order.length;e++)n.order[e]=[],n.info.count[e]=0;new Array(r);for(let e=0;e<t.length;e++){let s=t[e].length;n.order[s].push(t[e]),n.info.count[s]++}return{errorCode:0,data:n}}(c).data;switch(e){case 1:t.data=JSON.parse(JSON.stringify(d));break;case 2:t.error.state=1,t.error.reason="not implemented";default:t.data=JSON.parse(JSON.stringify(c))}return console.timeEnd("meshes-finder-duration"),console.log("Meshes-finder v"+_VERSION+" finished the job..."),t}}